# Dockerfile.api - For FastAPI Application

# ==============================================================================
# Stage 1: Builder - In this stage, we install all dependencies.
# ==============================================================================
# Use a full-featured Python image to have access to build tools.
# Using a specific version is a good practice for reproducibility.
FROM python:3.11-slim as builder

# Set the working directory inside the container
WORKDIR /app

# Install system-level dependencies that might be needed by Python packages
# (e.g., for cryptography or database connectors).
# We keep this minimal for now.
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Create a virtual environment to isolate dependencies
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy only the requirements file first to leverage Docker's layer caching.
# This layer will only be rebuilt if requirements.txt changes.
COPY requirements.txt .

# Install Python dependencies into the virtual environment
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt


# ==============================================================================
# Stage 2: Final - In this stage, we build the lean production image.
# ==============================================================================
# Use a slim Python image for the final container to reduce its size.
FROM python:3.11-slim

# Set the working directory
WORKDIR /app

# Copy the virtual environment from the builder stage.
# This contains all our pre-installed dependencies.
COPY --from=builder /opt/venv /opt/venv

# Copy the application code into the container.
# This includes the 'services', 'workers', 'providers', etc. directories.
COPY . .

# Set the PATH environment variable to use the virtual environment's Python and packages.
ENV PATH="/opt/venv/bin:$PATH"

# Expose the port the app will run on.
# Cloud Run will automatically use this, but it's good practice to declare it.
EXPOSE 8080

# Define the command to run the application using uvicorn.
# This will be the entry point of our container.
# We use --host 0.0.0.0 to make it accessible from outside the container.
CMD exec uvicorn services.api.app.main:app --host 0.0.0.0 --port $PORT